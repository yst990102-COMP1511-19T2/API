{{ copy_a_file(name="list_delete_ordered.c", change_function="remove_disorder") }}

<b>remove_disorder</b> is written using the following struct that cannot be changed:
<p>
<pre>
struct node {
    int data;
    struct node *next;
};
</pre>
<p>
The <b>node</b> struct is a normal linked list node containing an integer.
<p>
<b>remove_disorder</b> should take a pointer to the head of a <b>node</b> list
and return the head of the <b>node</b> list after it has removed any disorder 
in the list. A list is considered to have disorder if there are any nodes in it
that are higher in value (using the integer data) than the node directly after
them.
<p>
<b>remove_disorder</b> should remove nodes from the list, but otherwise make no
changes to the list itself.
<p>
For example if the list of nodes looks like this:
<pre>
{1, 3, 2}
</pre>
<p>
<b>remove_disorder</b> should return 
<pre>
{1, 2}
</pre>
<p>However, if the list looks like this:
<pre>
{2, 4, 5, 1}
</pre>
<p>
<b>remove_disorder</b> should return 
<pre>
{1}
</pre>
The 5 is definitely removed for being higher than the 1. After that, the 4
is then disordered because it is now next to the 1 and higher than it. Then, the
2 must be removed because it will be next to the 1 and higher than it.
<p>
<b>remove_disorder</b> should always return a list with no disorder in it. If 
any removals cause more disorder, these disordered <b>node</b>s must also be
removed before <b>remove_disorder</b> returns.

<h4>Assumptions/Restrictions/Clarifications.</h4>
<p>
<b>struct node</b> cannot be edited. It must be used as it is.
<p>
You may not use arrays in this solution. Arrays are not necessary to complete
this task.
<p>
You can assume that you'll never receive an empty list of <b>node</b>s.
</p></p></p></p></p></p></p></p></p></p></p></p>